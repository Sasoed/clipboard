[
    {
        "text": "хуй",
        "favorite": true
    },
    {
        "text": "Traceback (most recent call last):\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 64, in <lambda>\n    favorite_button.connect(\"toggled\", lambda btn, text=item[\"text\"]: self.toggle_favorite(text))\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 81, in toggle_favorite\n    self.update_ui(self.get_child())\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 44, in update_ui\n    all_page = notebook.get_nth_page(0).get_child()\nAttributeError: 'Box' object has no attribute 'get_nth_page'\nTraceback (most recent call last):\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 64, in <lambda>\n    favorite_button.connect(\"toggled\", lambda btn, text=item[\"text\"]: self.toggle_favorite(text))\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 81, in toggle_favorite\n    self.update_ui(self.get_child())\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 44, in update_ui\n    all_page = notebook.get_nth_page(0).get_child()\nAttributeError: 'Box' object has no attribute 'get_nth_page'\nTraceback (most recent call last):\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 64, in <lambda>\n    favorite_button.connect(\"toggled\", lambda btn, text=item[\"text\"]: self.toggle_favorite(text))\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 81, in toggle_favorite\n    self.update_ui(self.get_child())\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 44, in update_ui\n    all_page = notebook.get_nth_page(0).get_child()\nAttributeError: 'Box' object has no attribute 'get_nth_page'\n",
        "favorite": true
    },
    {
        "text": "import gi\ngi.require_version(\"Gtk\", \"3.0\")\nfrom gi.repository import Gtk, Gdk\nfrom functions import load_history, save_history, shorten_text\n\nclass ClipboardHistoryWindow(Gtk.Window):\n    def __init__(self):\n        super().__init__(title=\"История буфера обмена\")\n        self.set_default_size(400, 600)\n        self.set_position(Gtk.WindowPosition.CENTER)\n        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)\n        self.add(vbox)\n        notebook = Gtk.Notebook()\n        vbox.pack_start(notebook, True, True, 0)\n        self.init_pages(notebook)\n        self.add_clear_button(vbox, notebook)\n        self.update_ui(notebook)\n\n    def init_pages(self, notebook):\n        # Все элементы\n        all_scrollable_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)\n        all_scrolled_window = Gtk.ScrolledWindow()\n        all_scrolled_window.set_hexpand(True)\n        all_scrolled_window.set_vexpand(True)\n        all_scrolled_window.add(all_scrollable_box)\n        notebook.append_page(all_scrolled_window, Gtk.Label(label='Все'))\n\n        # Избранные элементы\n        fav_scrollable_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)\n        fav_scrolled_window = Gtk.ScrolledWindow()\n        fav_scrolled_window.set_hexpand(True)\n        fav_scrolled_window.set_vexpand(True)\n        fav_scrolled_window.add(fav_scrollable_box)\n        notebook.append_page(fav_scrolled_window, Gtk.Label(label='Избранные'))\n\n    def add_clear_button(self, vbox, notebook):\n        clear_button = Gtk.Button(label=\"Очистить историю и буфер обмена\")\n        clear_button.connect(\"clicked\", lambda btn: self.clear_clipboard_history(notebook))\n        vbox.pack_start(clear_button, False, False, 0)\n\n    def update_ui(self, notebook):\n        clipboard_history = load_history()\n        \n        all_page = notebook.get_nth_page(0).get_child()\n        fav_page = notebook.get_nth_page(1).get_child()\n\n        # Очищаем содержимое страниц\n        for child in all_page.get_children():\n            all_page.remove(child)\n        for child in fav_page.get_children():\n            fav_page.remove(child)\n\n        # Добавляем элементы в соответствующие страницы\n        for item in clipboard_history:\n            hbox = Gtk.Box(spacing=6)\n            button_text = shorten_text(item[\"text\"])\n            button = Gtk.Button(label=button_text)\n            button.connect(\"clicked\", lambda btn, text=item[\"text\"]: self.copy_to_clipboard(text))\n            hbox.pack_start(button, True, True, 0)\n\n            favorite_button = Gtk.ToggleButton()\n            favorite_button.set_label(\"☆\" if not item.get(\"favorite\", False) else \"★\")\n            favorite_button.set_active(item.get(\"favorite\", False))\n            favorite_button.connect(\"toggled\", lambda btn, text=item[\"text\"]: self.toggle_favorite(text))\n            hbox.pack_start(favorite_button, False, False, 0)\n\n            if item.get(\"favorite\", False):\n                fav_page.add(hbox)\n            else:\n                all_page.add(hbox)\n\n        notebook.show_all()\n\n    def toggle_favorite(self, item_text):\n        history = load_history()\n        for item in history:\n            if item[\"text\"] == item_text:\n                item[\"favorite\"] = not item.get(\"favorite\", False)\n                break\n        save_history(history)\n        self.update_ui(self.get_child())\n\n    def clear_clipboard_history(self, notebook):\n        save_history([])\n        self.update_ui(notebook)\n        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)\n        clipboard.clear()\n\n    def copy_to_clipboard(self, text):\n        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)\n        clipboard.set_text(text, -1)\n\ndef main():\n    win = ClipboardHistoryWindow()\n    win.connect(\"destroy\", Gtk.main_quit)\n    win.show_all()\n    Gtk.main()\n\nif __name__ == \"__main__\":\n    main()\n",
        "favorite": false
    },
    {
        "text": "Обнаружено новое содержимое буфера обмена. Сохранение...\n",
        "favorite": false
    },
    {
        "text": "Traceback (most recent call last):\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 64, in <lambda>\n    favorite_button.connect(\"toggled\", lambda btn, text=item[\"text\"]: self.toggle_favorite(text))\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 81, in toggle_favorite\n    self.update_ui(self.get_child())\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 44, in update_ui\n    all_page = notebook.get_nth_page(0).get_child()\nAttributeError: 'Box' object has no attribute 'get_nth_page'\nTraceback (most recent call last):\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 64, in <lambda>\n    favorite_button.connect(\"toggled\", lambda btn, text=item[\"text\"]: self.toggle_favorite(text))\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 81, in toggle_favorite\n    self.update_ui(self.get_child())\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 44, in update_ui\n    all_page = notebook.get_nth_page(0).get_child()\nAttributeError: 'Box' object has no attribute 'get_nth_page'\n",
        "favorite": false
    },
    {
        "text": "import gi\ngi.require_version(\"Gtk\", \"3.0\")\nfrom gi.repository import Gtk, Gdk\nfrom functions import load_history, save_history, shorten_text\n\nclass ClipboardHistoryWindow(Gtk.Window):\n    def __init__(self):\n        super().__init__(title=\"История буфера обмена\")\n        self.set_default_size(400, 600)\n        self.set_position(Gtk.WindowPosition.CENTER)\n        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)\n        self.add(vbox)\n        notebook = Gtk.Notebook()\n        vbox.pack_start(notebook, True, True, 0)\n        self.init_pages(notebook)\n        self.add_clear_button(vbox, notebook)\n        self.update_ui(notebook)\n\n    def init_pages(self, notebook):\n        # Все элементы\n        all_scrollable_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)\n        all_scrolled_window = Gtk.ScrolledWindow()\n        all_scrolled_window.set_hexpand(True)\n        all_scrolled_window.set_vexpand(True)\n        all_scrolled_window.add(all_scrollable_box)\n        notebook.append_page(all_scrolled_window, Gtk.Label(label='Все'))\n\n        # Избранные элементы\n        fav_scrollable_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)\n        fav_scrolled_window = Gtk.ScrolledWindow()\n        fav_scrolled_window.set_hexpand(True)\n        fav_scrolled_window.set_vexpand(True)\n        fav_scrolled_window.add(fav_scrollable_box)\n        notebook.append_page(fav_scrolled_window, Gtk.Label(label='Избранные'))\n\n    def add_clear_button(self, vbox, notebook):\n        clear_button = Gtk.Button(label=\"Очистить историю и буфер обмена\")\n        clear_button.connect(\"clicked\", lambda btn: self.clear_clipboard_history(notebook))\n        vbox.pack_start(clear_button, False, False, 0)\n\n    def update_ui(self, notebook):\n        clipboard_history = load_history()\n        \n        all_page = notebook.get_nth_page(0).get_child()\n        fav_page = notebook.get_nth_page(1).get_child()\n\n        # Очищаем содержимое страниц\n        for child in all_page.get_children():\n            all_page.remove(child)\n        for child in fav_page.get_children():\n            fav_page.remove(child)\n\n        # Добавляем элементы в соответствующие страницы\n        for item in clipboard_history:\n            hbox = Gtk.Box(spacing=6)\n            button_text = shorten_text(item[\"text\"])\n            button = Gtk.Button(label=button_text)\n            button.connect(\"clicked\", lambda btn, text=item[\"text\"]: self.copy_to_clipboard(text))\n            hbox.pack_start(button, True, True, 0)\n\n            favorite_button = Gtk.ToggleButton()\n            favorite_button.set_label(\"☆\" if not item.get(\"favorite\", False) else \"★\")\n            favorite_button.set_active(item.get(\"favorite\", False))\n            favorite_button.connect(\"toggled\", lambda btn, text=item[\"text\"]: self.toggle_favorite(text))\n            hbox.pack_start(favorite_button, False, False, 0)\n\n            if item.get(\"favorite\", False):\n                fav_page.add(hbox)\n            else:\n                all_page.add(hbox)\n\n        notebook.show_all()\n\n    def toggle_favorite(self, item_text):\n        history = load_history()\n        for item in history:\n            if item[\"text\"] == item_text:\n                item[\"favorite\"] = not item.get(\"favorite\", False)\n                break\n        save_history(history)\n        notebook = self.get_child()  # Получаем объект Gtk.Notebook\n        self.update_ui(notebook)\n\n    def clear_clipboard_history(self, notebook):\n        save_history([])\n        self.update_ui(notebook)\n        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)\n        clipboard.clear()\n\n    def copy_to_clipboard(self, text):\n        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)\n        clipboard.set_text(text, -1)\n\ndef main():\n    win = ClipboardHistoryWindow()\n    win.connect(\"destroy\", Gtk.main_quit)\n    win.show_all()\n    Gtk.main()\n\nif __name__ == \"__main__\":\n    main()\n",
        "favorite": false
    },
    {
        "text": "Traceback (most recent call last):\r\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 64, in <lambda>\r\n    favorite_button.connect(\"toggled\", lambda btn, text=item[\"text\"]: self.toggle_favorite(text))\r\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 81, in toggle_favorite\r\n    self.update_ui(self.get_child())\r\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 44, in update_ui\r\n    all_page = notebook.get_nth_page(0).get_child()\r\nAttributeError: 'Box' object has no attribute 'get_nth_page'\r\nTraceback (most recent call last):\r\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 64, in <lambda>\r\n    favorite_button.connect(\"toggled\", lambda btn, text=item[\"text\"]: self.toggle_favorite(text))\r\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 81, in toggle_favorite\r\n    self.update_ui(self.get_child())\r\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 44, in update_ui\r\n    all_page = notebook.get_nth_page(0).get_child()\r\nAttributeError: 'Box' object has no attribute 'get_nth_page'\r\nTraceback (most recent call last):\r\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 64, in <lambda>\r\n    favorite_button.connect(\"toggled\", lambda btn, text=item[\"text\"]: self.toggle_favorite(text))\r\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 81, in toggle_favorite\r\n    self.update_ui(self.get_child())\r\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 44, in update_ui\r\n    all_page = notebook.get_nth_page(0).get_child()\r\nAttributeError: 'Box' object has no attribute 'get_nth_page'\r\n",
        "favorite": false
    },
    {
        "text": "Traceback (most recent call last):\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 64, in <lambda>\n    favorite_button.connect(\"toggled\", lambda btn, text=item[\"text\"]: self.toggle_favorite(text))\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 82, in toggle_favorite\n    self.update_ui(notebook)\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 44, in update_ui\n    all_page = notebook.get_nth_page(0).get_child()\nAttributeError: 'Box' object has no attribute 'get_nth_page'\nseva@seva:~/Документы/projects/Python/clipboard$ \n",
        "favorite": false
    },
    {
        "text": "import gi\ngi.require_version(\"Gtk\", \"3.0\")\nfrom gi.repository import Gtk, Gdk\nfrom functions import load_history, save_history, shorten_text\n\nclass ClipboardHistoryWindow(Gtk.Window):\n    def __init__(self):\n        super().__init__(title=\"История буфера обмена\")\n        self.set_default_size(400, 600)\n        self.set_position(Gtk.WindowPosition.CENTER)\n        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)\n        self.add(vbox)\n        notebook = Gtk.Notebook()\n        vbox.pack_start(notebook, True, True, 0)\n        self.init_pages(notebook)\n        self.add_clear_button(vbox, notebook)\n        self.update_ui(notebook)\n\n    def init_pages(self, notebook):\n        # Все элементы\n        all_scrollable_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)\n        all_scrolled_window = Gtk.ScrolledWindow()\n        all_scrolled_window.set_hexpand(True)\n        all_scrolled_window.set_vexpand(True)\n        all_scrolled_window.add(all_scrollable_box)\n        notebook.append_page(all_scrolled_window, Gtk.Label(label='Все'))\n\n        # Избранные элементы\n        fav_scrollable_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)\n        fav_scrolled_window = Gtk.ScrolledWindow()\n        fav_scrolled_window.set_hexpand(True)\n        fav_scrolled_window.set_vexpand(True)\n        fav_scrolled_window.add(fav_scrollable_box)\n        notebook.append_page(fav_scrolled_window, Gtk.Label(label='Избранные'))\n\n    def add_clear_button(self, vbox, notebook):\n        clear_button = Gtk.Button(label=\"Очистить историю и буфер обмена\")\n        clear_button.connect(\"clicked\", lambda btn: self.clear_clipboard_history(notebook))\n        vbox.pack_start(clear_button, False, False, 0)\n\n    def update_ui(self, notebook):\n        clipboard_history = load_history()\n        \n        all_page = notebook.get_nth_page(0).get_child()\n        fav_page = notebook.get_nth_page(1).get_child()\n\n        # Очищаем содержимое страниц\n        for child in all_page.get_children():\n            all_page.remove(child)\n        for child in fav_page.get_children():\n            fav_page.remove(child)\n\n        # Добавляем элементы в соответствующие страницы\n        for item in clipboard_history:\n            hbox = Gtk.Box(spacing=6)\n            button_text = shorten_text(item[\"text\"])\n            button = Gtk.Button(label=button_text)\n            button.connect(\"clicked\", lambda btn, text=item[\"text\"]: self.copy_to_clipboard(text))\n            hbox.pack_start(button, True, True, 0)\n\n            favorite_button = Gtk.ToggleButton()\n            favorite_button.set_label(\"☆\" if not item.get(\"favorite\", False) else \"★\")\n            favorite_button.set_active(item.get(\"favorite\", False))\n            favorite_button.connect(\"toggled\", lambda btn, text=item[\"text\"]: self.toggle_favorite(text))\n            hbox.pack_start(favorite_button, False, False, 0)\n\n            if item.get(\"favorite\", False):\n                fav_page.add(hbox)\n            else:\n                all_page.add(hbox)\n\n        notebook.show_all()\n\n    def toggle_favorite(self, item_text):\n        history = load_history()\n        for item in history:\n            if item[\"text\"] == item_text:\n                item[\"favorite\"] = not item.get(\"favorite\", False)\n                break\n        save_history(history)\n        notebook = self.get_child().get_child()  # Получаем объект Gtk.Notebook\n        self.update_ui(notebook)\n\n    def clear_clipboard_history(self, notebook):\n        save_history([])\n        self.update_ui(notebook)\n        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)\n        clipboard.clear()\n\n    def copy_to_clipboard(self, text):\n        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)\n        clipboard.set_text(text, -1)\n\ndef main():\n    win = ClipboardHistoryWindow()\n    win.connect(\"destroy\", Gtk.main_quit)\n    win.show_all()\n    Gtk.main()\n\nif __name__ == \"__main__\":\n    main()\n",
        "favorite": false
    },
    {
        "text": "Traceback (most recent call last):\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 64, in <lambda>\n    favorite_button.connect(\"toggled\", lambda btn, text=item[\"text\"]: self.toggle_favorite(text))\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 81, in toggle_favorite\n    notebook = self.get_child().get_child()  # Получаем объект Gtk.Notebook\n",
        "favorite": false
    },
    {
        "text": "def toggle_favorite(self, item_text):\n    history = load_history()\n    for item in history:\n        if item[\"text\"] == item_text:\n            item[\"favorite\"] = not item.get(\"favorite\", False)\n            break\n    save_history(history)\n    notebook = self.get_parent().get_parent()  # Получаем объект Gtk.Notebook\n    self.update_ui(notebook)\n",
        "favorite": false
    },
    {
        "text": "import gi\ngi.require_version(\"Gtk\", \"3.0\")\nfrom gi.repository import Gtk, Gdk\nfrom functions import load_history, save_history, shorten_text\n\nclass ClipboardHistoryWindow(Gtk.Window):\n    def __init__(self):\n        super().__init__(title=\"История буфера обмена\")\n        self.set_default_size(400, 600)\n        self.set_position(Gtk.WindowPosition.CENTER)\n        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)\n        self.add(vbox)\n        notebook = Gtk.Notebook()\n        vbox.pack_start(notebook, True, True, 0)\n        self.init_pages(notebook)\n        self.add_clear_button(vbox, notebook)\n        self.update_ui(notebook)\n\n    def init_pages(self, notebook):\n        # Все элементы\n        all_scrollable_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)\n        all_scrolled_window = Gtk.ScrolledWindow()\n        all_scrolled_window.set_hexpand(True)\n        all_scrolled_window.set_vexpand(True)\n        all_scrolled_window.add(all_scrollable_box)\n        notebook.append_page(all_scrolled_window, Gtk.Label(label='Все'))\n\n        # Избранные элементы\n        fav_scrollable_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)\n        fav_scrolled_window = Gtk.ScrolledWindow()\n        fav_scrolled_window.set_hexpand(True)\n        fav_scrolled_window.set_vexpand(True)\n        fav_scrolled_window.add(fav_scrollable_box)\n        notebook.append_page(fav_scrolled_window, Gtk.Label(label='Избранные'))\n\n    def add_clear_button(self, vbox, notebook):\n        clear_button = Gtk.Button(label=\"Очистить историю и буфер обмена\")\n        clear_button.connect(\"clicked\", lambda btn: self.clear_clipboard_history(notebook))\n        vbox.pack_start(clear_button, False, False, 0)\n\n    def update_ui(self, notebook):\n        clipboard_history = load_history()\n        \n        all_page = notebook.get_nth_page(0).get_child()\n        fav_page = notebook.get_nth_page(1).get_child()\n\n        # Очищаем содержимое страниц\n        for child in all_page.get_children():\n            all_page.remove(child)\n        for child in fav_page.get_children():\n            fav_page.remove(child)\n\n        # Добавляем элементы в соответствующие страницы\n        for item in clipboard_history:\n            hbox = Gtk.Box(spacing=6)\n            button_text = shorten_text(item[\"text\"])\n            button = Gtk.Button(label=button_text)\n            button.connect(\"clicked\", lambda btn, text=item[\"text\"]: self.copy_to_clipboard(text))\n            hbox.pack_start(button, True, True, 0)\n\n            favorite_button = Gtk.ToggleButton()\n            favorite_button.set_label(\"☆\" if not item.get(\"favorite\", False) else \"★\")\n            favorite_button.set_active(item.get(\"favorite\", False))\n            favorite_button.connect(\"toggled\", lambda btn, text=item[\"text\"]: self.toggle_favorite(text))\n            hbox.pack_start(favorite_button, False, False, 0)\n\n            if item.get(\"favorite\", False):\n                fav_page.add(hbox)\n            else:\n                all_page.add(hbox)\n\n        notebook.show_all()\n\n    def toggle_favorite(self, item_text):\n        history = load_history()\n        for item in history:\n            if item[\"text\"] == item_text:\n                item[\"favorite\"] = not item.get(\"favorite\", False)\n                break\n        save_history(history)\n        notebook = self.get_parent().get_parent()  # Получаем объект Gtk.Notebook\n        self.update_ui(notebook)\n\n    def clear_clipboard_history(self, notebook):\n        save_history([])\n        self.update_ui(notebook)\n        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)\n        clipboard.clear()\n\n    def copy_to_clipboard(self, text):\n        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)\n        clipboard.set_text(text, -1)\n\ndef main():\n    win = ClipboardHistoryWindow()\n    win.connect(\"destroy\", Gtk.main_quit)\n    win.show_all()\n    Gtk.main()\n\nif __name__ == \"__main__\":\n    main()\n",
        "favorite": false
    },
    {
        "text": "Traceback (most recent call last):\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 64, in <lambda>\n    favorite_button.connect(\"toggled\", lambda btn, text=item[\"text\"]: self.toggle_favorite(text))\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 81, in toggle_favorite\n    notebook = self.get_parent().get_parent()  # Получаем объект Gtk.Notebook\nAttributeError: 'NoneType' object has no attribute 'get_parent'\nTraceback (most recent call last):\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 64, in <lambda>\n    favorite_button.connect(\"toggled\", lambda btn, text=item[\"text\"]: self.toggle_favorite(text))\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 81, in toggle_favorite\n    notebook = self.get_parent().get_parent()  # Получаем объект Gtk.Notebook\nAttributeError: 'NoneType' object has no attribute 'get_parent'\n",
        "favorite": false
    },
    {
        "text": "import gi\ngi.require_version(\"Gtk\", \"3.0\")\nfrom gi.repository import Gtk, Gdk\nfrom functions import load_history, save_history, shorten_text\n\nclass ClipboardHistoryWindow(Gtk.Window):\n    def __init__(self):\n        super().__init__(title=\"История буфера обмена\")\n        self.set_default_size(400, 600)\n        self.set_position(Gtk.WindowPosition.CENTER)\n        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)\n        self.add(vbox)\n        notebook = Gtk.Notebook()\n        vbox.pack_start(notebook, True, True, 0)\n        self.init_pages(notebook)\n        self.add_clear_button(vbox, notebook)\n        self.update_ui(notebook)\n\n    def init_pages(self, notebook):\n        # Все элементы\n        all_scrollable_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)\n        all_scrolled_window = Gtk.ScrolledWindow()\n        all_scrolled_window.set_hexpand(True)\n        all_scrolled_window.set_vexpand(True)\n        all_scrolled_window.add(all_scrollable_box)\n        notebook.append_page(all_scrolled_window, Gtk.Label(label='Все'))\n\n        # Избранные элементы\n        fav_scrollable_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)\n        fav_scrolled_window = Gtk.ScrolledWindow()\n        fav_scrolled_window.set_hexpand(True)\n        fav_scrolled_window.set_vexpand(True)\n        fav_scrolled_window.add(fav_scrollable_box)\n        notebook.append_page(fav_scrolled_window, Gtk.Label(label='Избранные'))\n\n    def add_clear_button(self, vbox, notebook):\n        clear_button = Gtk.Button(label=\"Очистить историю и буфер обмена\")\n        clear_button.connect(\"clicked\", self.clear_clipboard_history, notebook)\n        vbox.pack_start(clear_button, False, False, 0)\n\n    def update_ui(self, notebook):\n        clipboard_history = load_history()\n        \n        all_page = notebook.get_nth_page(0).get_child()\n        fav_page = notebook.get_nth_page(1).get_child()\n\n        # Очищаем содержимое страниц\n        for child in all_page.get_children():\n            all_page.remove(child)\n        for child in fav_page.get_children():\n            fav_page.remove(child)\n\n        # Добавляем элементы в соответствующие страницы\n        for item in clipboard_history:\n            hbox = Gtk.Box(spacing=6)\n            button_text = shorten_text(item[\"text\"])\n            button = Gtk.Button(label=button_text)\n            button.connect(\"clicked\", self.copy_to_clipboard, item[\"text\"])\n            hbox.pack_start(button, True, True, 0)\n\n            favorite_button = Gtk.ToggleButton()\n            favorite_button.set_label(\"☆\" if not item.get(\"favorite\", False) else \"★\")\n            favorite_button.set_active(item.get(\"favorite\", False))\n            favorite_button.connect(\"toggled\", self.toggle_favorite, item[\"text\"])\n            hbox.pack_start(favorite_button, False, False, 0)\n\n            if item.get(\"favorite\", False):\n                fav_page.add(hbox)\n            else:\n                all_page.add(hbox)\n\n        notebook.show_all()\n\n    def toggle_favorite(self, button, item_text):\n        history = load_history()\n        for item in history:\n            if item[\"text\"] == item_text:\n                item[\"favorite\"] = not item.get(\"favorite\", False)\n                break\n        save_history(history)\n        self.update_ui(button.get_parent().get_parent())\n\n    def clear_clipboard_history(self, button, notebook):\n        save_history([])\n        self.update_ui(notebook)\n        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)\n        clipboard.clear()\n\n    def copy_to_clipboard(self, button, text):\n        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)\n        clipboard.set_text(text, -1)\n\ndef main():\n    win = ClipboardHistoryWindow()\n    win.connect(\"destroy\", Gtk.main_quit)\n    win.show_all()\n    Gtk.main()\n\nif __name__ == \"__main__\":\n    main()\n",
        "favorite": false
    },
    {
        "text": "Traceback (most recent call last):\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 81, in toggle_favorite\n    self.update_ui(button.get_parent().get_parent())\n  File \"/home/seva/Документы/projects/Python/clipboard/clipboard.py\", line 44, in update_ui\n    all_page = notebook.get_nth_page(0).get_child()\nAttributeError: 'Viewport' object has no attribute 'get_nth_page'\n",
        "favorite": false
    },
    {
        "text": "import gi\ngi.require_version(\"Gtk\", \"3.0\")\nfrom gi.repository import Gtk, Gdk\nfrom functions import load_history, save_history, shorten_text  # Assuming functions.py exists\n\nclass ClipboardHistoryWindow(Gtk.Window):\n    def __init__(self):\n        super().__init__(title=\"История буфера обмена\")\n        self.set_default_size(400, 600)\n        self.set_position(Gtk.WindowPosition.CENTER)\n        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)\n        self.add(vbox)\n        notebook = Gtk.Notebook()\n        vbox.pack_start(notebook, True, True, 0)\n        self.init_pages(notebook)\n        self.add_clear_button(vbox, notebook)\n        self.update_ui(notebook)\n\n    def init_pages(self, notebook):\n        # All elements\n        all_scrollable_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)\n        all_scrolled_window = Gtk.ScrolledWindow()\n        all_scrolled_window.set_hexpand(True)\n        all_scrolled_window.set_vexpand(True)\n        all_scrolled_window.add(all_scrollable_box)\n        notebook.append_page(all_scrolled_window, Gtk.Label(label='Все'))\n\n        # Favored elements\n        fav_scrollable_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)\n        fav_scrolled_window = Gtk.ScrolledWindow()\n        fav_scrolled_window.set_hexpand(True)\n        fav_scrolled_window.set_vexpand(True)\n        fav_scrolled_window.add(fav_scrollable_box)\n        notebook.append_page(fav_scrolled_window, Gtk.Label(label='Избранные'))\n\n    def add_clear_button(self, vbox, notebook):\n        clear_button = Gtk.Button(label=\"Очистить историю и буфер обмена\")\n        clear_button.connect(\"clicked\", self.clear_clipboard_history, notebook)\n        vbox.pack_start(clear_button, False, False, 0)\n\n    def update_ui(self, notebook):\n        clipboard_history = load_history()\n\n        all_page = notebook.get_nth_page(0).get_child()\n        fav_page = notebook.get_nth_page(1).get_child()\n\n        # Очистить страницы\n        for child in all_page.get_children():\n            all_page.remove(child)\n        for child in fav_page.get_children():\n            fav_page.remove(child)\n\n        # Добавить элементы на страницы\n        for item in clipboard_history:\n            hbox = Gtk.Box(spacing=6)\n            button_text = shorten_text(item[\"text\"])\n            button = Gtk.Button(label\n",
        "favorite": false
    },
    {
        "text": "sk-2ae6eae8ff6745c8879f21aaf416b0e5",
        "favorite": false
    },
    {
        "text": "# python3\nfrom openai import OpenAI\n\nclient = OpenAI(api_key=\"<deepseek api key>\", base_url=\"https://api.deepseek.com/v1\")\n\nresponse = client.chat.completions.create(\n    model=\"deepseek-chat\",\n    messages=[\n        {\"role\": \"system\", \"content\": \"You are a helpful assistant\"},\n        {\"role\": \"user\", \"content\": \"Hello\"},\n    ]\n)\n\nprint(response.choices[0].message.content)\n",
        "favorite": false
    },
    {
        "text": "Представьте себе красивую девушку с длинными волнистыми волосами, которые падают на ее плечи. У нее большие голубые глаза и улыбка, которая может зажечь комнату. Она носит простой, но стильный наряд, который подчеркивает ее фигуру. Ее походка уверенная и грациозная, и она производит впечатление уверенной и сильной женщины.",
        "favorite": false
    },
    {
        "text": "В Unity, объединение объектов в один, как это делается в Blender, осуществляется немного иначе, потому что Unity — это в первую очередь игровой движок, а не инструмент моделирования. Однако, есть несколько способов, которыми вы можете достичь аналогичного результата, объединив объекты для различных целей.\n\n### 1. Создание родительского объекта (Parenting)\nСамый простой способ объединить объекты в Unity — это использовать иерархию родительских и дочерних объектов. Вы можете перетащить один объект на другой в окне иерархии (Hierarchy), чтобы сделать его дочерним. Это не сливает меш (mesh) объектов в один, но позволяет управлять группой объектов как единым целым.\n\n### 2. Использование скриптов для слияния мешей\nЕсли вам нужно буквально объединить несколько мешей в один для оптимизации или других целей, вы можете сделать это с помощью C# скрипта. Скрипт может перебрать все дочерние объекты выбранного родительского объекта, объединить их меши в один и применить этот новый меш к родительскому объекту. Это более сложный процесс, требующий понимания работы с мешами в Unity и программирования на C#.\n\n### 3. Использование сторонних плагинов\nСуществуют плагины и расширения для Unity, которые могут упростить процесс объединения объектов, например, Mesh Baker или ProBuilder (теперь интегрирован в Unity). Эти инструменты предоставляют более продвинутые возможности для работы с мешами, включая объединение.\n\n### Пример скрипта для объединения мешей:\nНиже представлен базовый пример скрипта, который может объединять меши дочерних объектов в один. Этот скрипт должен быть прикреплен к родительскому объекту, содержащему объекты, которые вы хотите объединить.\n\n```csharp\nusing UnityEngine;\n\n[RequireComponent(typeof(MeshFilter))]\n[RequireComponent(typeof(MeshRenderer))]\npublic class MeshCombiner : MonoBehaviour\n{\n    void Start()\n    {\n        CombineMeshes();\n    }\n\n    void CombineMeshes()\n    {\n        MeshFilter[] meshFilters = GetComponentsInChildren<MeshFilter>();\n        CombineInstance[] combine = new CombineInstance[meshFilters.Length-1];\n        int index = 0;\n        Material material = null;\n\n        foreach (MeshFilter meshFilter in meshFilters)\n        {\n            if (meshFilter.sharedMesh == null) continue;\n            if (material == null) material = meshFilter.GetComponent<MeshRenderer>().sharedMaterial;\n            combine[index].mesh = meshFilter.sharedMesh;\n            combine[index++].transform = meshFilter.transform.localToWorldMatrix;\n            meshFilter.gameObject.SetActive(false);\n        }\n\n        MeshFilter thisMeshFilter = GetComponent<MeshFilter>();\n        thisMeshFilter.mesh = new Mesh();\n        thisMeshFilter.mesh.CombineMeshes(combine, true, true);\n        MeshRenderer meshRenderer = GetComponent<MeshRenderer>();\n        meshRenderer.material = material;\n\n        gameObject.SetActive(true);\n    }\n}\n```\n\nОбратите внимание, что этот скрипт объединит все меши дочерних объектов в один меш и применит его к родительскому объекту, который должен иметь компоненты `MeshFilter` и `MeshRenderer`. Этот метод работает хорошо для статичных объектов, но может быть не подходит для объектов, которые требуют индивидуальной анимации или других динамических изменений.",
        "favorite": false
    },
    {
        "text": "",
        "favorite": false
    },
    {
        "text": "Gaijin Entertainment",
        "favorite": false
    },
    {
        "text": "аговор Nvidia против продажи красных кружек в EC\n\n",
        "favorite": false
    },
    {
        "text": "Создадим вымышленную историю о заговоре, связанном с различными типами электрических розеток в мире и том, как на этом, согласно нашей выдуманной истории, зарабатывают Илон Маск, Джо Байден и бренд Calvin Klein. Помните, что всё это абсолютно вымышленный сюжет, придуманный исключительно в развлекательных целях.\n\n---\n\n**Мировой заговор розеток: неожиданная связь между Илоном Маском, Джо Байденом и Calvin Klein**\n\nВ мире, где каждая страна имеет свой стандарт электрических розеток, кажется, что несоответствие между ними является лишь недоразумением истории и технологий. Однако недавно был раскрыт масштабный заговор, стоящий за этим кажущимся хаосом. В центре событий оказались Илон Маск, Джо Байден и международный модный бренд Calvin Klein. Согласно полученной информации, эта неожиданная троица на самом деле давно сотрудничает, извлекая огромную прибыль из глобальной путаницы с розетками.\n\nИстория началась несколько лет назад, когда Илон Маск, стремясь расширить рынок для своих электромобилей Tesla, столкнулся с проблемой разнообразия электрических стандартов в разных странах. Вместо того чтобы пытаться унифицировать эти стандарты, Маск предложил создать уникальный адаптер, который не только сделает возможной зарядку Tesla в любой стране мира, но и станет незаменимым аксессуаром для любого устройства.\n\nДжо Байден, заинтересованный в продвижении американских технологий за рубежом, тайно поддержал эту идею, видя в ней возможность укрепления технологического доминирования США. Однако для успешной реализации плана требовалось вовлечь в схему и модный сегмент, чтобы сделать адаптер не только функциональным, но и желанным предметом. Здесь на сцену вышел Calvin Klein.\n\nМодный бренд взял на себя задачу по проектированию и производству адаптеров, которые были бы не только технологически продвинутыми, но и стильными. Адаптеры были представлены как часть новой коллекции аксессуаров, что моментально сделало их культовым предметом среди поклонников моды и технологий по всему миру.\n\nТаким образом, объединив усилия, Илон Маск, Джо Байден и Calvin Klein создали мощный источник прибыли, одновременно продвигая американские технологии и моду. Несмотря на то, что публично они никогда не признавали своего участия в этом заговоре",
        "favorite": false
    },
    {
        "text": "Давай представим сюжет для заговора производителей котлет против Genshin Impact косплееров.\n\n---\n\nВ тени скрытых корпоративных сговоров зародился заговор производителей котлет, чей бизнес стал заметно страдать из-за растущей популярности Genshin Impact. Когда косплееры стали массово переодеваться в персонажей из этой игры и появилась мода на рестораны в стиле Genshin Impact, производители котлет поняли, что их привычное дело под угрозой.\n\nРуководимые жаждой сохранить свои прибыли, они замыслили коварный план. Под прикрытием благотворительной акции, они начали поставлять косплеерам бесплатное мясо для котлет. Однако, что они скрывали, это то, что мясо было обработано специальным составом, который вызывал аллергические реакции у тех, кто употреблял его.\n\nЗаговорщики распространили слухи о \"Геншин-интолерантности\", предполагая, что косплееры, страдающие от аллергических реакций, будут вынуждены отказаться от своих костюмов и ресторанов в стиле Genshin Impact из-за страха за свое здоровье. Это должно было уменьшить популярность игры и, следовательно, вернуть спрос на котлеты.\n\nОднако заговорщики не учли силы сообщества косплееров и фанатов Genshin Impact. Они сразу же начали исследования, выявляя истинную причину аллергических реакций и просвещая общественность о зловредном заговоре производителей котлет. Вскоре планы заговорщиков были раскрыты, и общественное осуждение их действий было оглушительным.\n\nПод давлением общественности и правительства, производители котлет были вынуждены признать свою вину и возместить ущерб, нанесенный косплеерам и фанатам Genshin Impact. Заговор был разоблачен, но урок был выучен: никакие темные планы не могут потушить пыл и страсть фанатов к их любимым произведениям и персонажам.",
        "favorite": false
    },
    {
        "text": "seva@seva:~/Документы/projects/Python/clipboard$ py\npy3clean           pybabel-python3    pygettext3.10      python3.10-config\npy3compile         pydoc3             pygmentize         python3-config\npy3versions        pydoc3.10          python3            \npybabel            pygettext3         python3.10         \nseva@seva:~/Документы/projects/Python/clipboard$ python3 main.py \n",
        "favorite": false
    },
    {
        "text": "/home/seva/Документы/projects/Python/clipboard/clipboard_history.json",
        "favorite": false
    },
    {
        "text": "import json\n\nclipboard_history_file = '/home/seva/Документы/projects/Python/clipboard/clipboard_history.json'\n\ndef load_history():\n    try:\n        with open(clipboard_history_file, 'r') as file:\n            history = json.load(file)\n        return history\n    except FileNotFoundError:\n        return []\n\ndef save_history(history):\n    with open(clipboard_history_file, 'w') as file:\n        json.dump(history, file)\n\ndef shorten_text(text, limit=50):\n    return text if len(text) <= limit else text[:limit-3] + \"...\"\n",
        "favorite": false
    },
    {
        "text": "def update_ui(self, notebook):\n    clipboard_history = load_history()\n    clipboard_history = reversed(clipboard_history)  # Инвертируем порядок списка\n\n    all_page = notebook.get_nth_page(0).get_child()\n    fav_page = notebook.get_nth_page(1).get_child()\n\n    # Очищаем содержимое страниц\n    for child in all_page.get_children():\n        all_page.remove(child)\n    for child in fav_page.get_children():\n        fav_page.remove(child)\n\n    # Добавляем элементы в соответствующие страницы\n    for item in clipboard_history:\n        hbox = Gtk.Box(spacing=6)\n        button_text = shorten_text(item[\"text\"])\n        button = Gtk.Button(label=button_text)\n        button.connect(\"clicked\", self.copy_to_clipboard, item[\"text\"])\n        hbox.pack_start(button, True, True, 0)\n\n        favorite_button = Gtk.ToggleButton()\n        favorite_button.set_label(\"☆\" if not item.get(\"favorite\", False) else \"★\")\n        favorite_button.set_active(item.get(\"favorite\", False))\n        favorite_button.connect(\"toggled\", self.toggle_favorite, item[\"text\"])\n        hbox.pack_start(favorite_button, False, False, 0)\n\n        if item.get(\"favorite\", False):\n            fav_page.add(hbox)\n        else:\n            all_page.add(hbox)\n\n    notebook.show_all()\n",
        "favorite": false
    },
    {
        "text": "def update_ui(self, notebook):\n    clipboard_history = load_history()\n    clipboard_history = reversed(clipboard_history)  # Инвертируем порядок списка\n\n    all_page = notebook.get_nth_page(0).get_child()\n    fav_page = notebook.get_nth_page(1).get_child()\n\n    # Очищаем содержимое страниц\n    for child in all_page.get_children():\n        all_page.remove(child)\n    for child in fav_page.get_children():\n        fav_page.remove(child)\n\n    # Добавляем элементы в соответствующие страницы\n    for item in clipboard_history:\n        hbox = Gtk.Box(spacing=6)\n        button_text = shorten_text(item[\"text\"])\n        button = Gtk.Button(label=button_text)\n        button.connect(\"clicked\", self.copy_to_clipboard, item[\"text\"])\n        hbox.pack_start(button, True, True, 0)\n\n        favorite_button = Gtk.ToggleButton()\n        favorite_button.set_label(\"☆\" if not item.get(\"favorite\", False) else \"★\")\n        favorite_button.set_active(item.get(\"favorite\", False))\n        favorite_button.connect(\"toggled\", self.toggle_favorite, item[\"text\"])\n        hbox.pack_start(favorite_button, False, False, 0)\n\n        if item.get(\"favorite\", False):\n            fav_page.add(hbox)\n        else:\n            all_page.add(hbox)\n\n    notebook.show_all()",
        "favorite": false
    },
    {
        "text": "def update_ui(self, notebook):\n    clipboard_history = load_history()\n    clipboard_history = reversed(clipboard_history)  # Инвертируем порядок списка",
        "favorite": false
    },
    {
        "text": "clipboard_history = reversed(clipboard_history)  # Инвертируем порядок списка",
        "favorite": false
    },
    {
        "text": "hbox = Gtk.Box(spacing=6)\n        button_text = shorten_text(item[\"text\"])\n        button = Gtk.Button(label=button_text)\n        button.connect(\"clicked\", self.copy_to_clipboard, item[\"text\"])\n        hbox.pack_start(button, True, True, 0)\n\n        favorite_button = Gtk.ToggleButton()\n        favorite_button.set_label(\"☆\" if not item.get(\"favorite\", False) else \"★\")\n        favorite_button.set_active(item.get(\"favorite\", False))\n        favorite_button.connect(\"toggled\", self.toggle_favorite, item[\"text\"])\n        hbox.pack_start(favorite_button, False, False, 0)",
        "favorite": false
    },
    {
        "text": "hbox = Gtk.Box(spacing=6)\n        button_text = shorten_text(item[\"text\"])\n        button = Gtk.Button(label=button_text)\n        button.connect(\"clicked\", self.copy_to_clipboard, item[\"text\"])\n        hbox.pack_start(button, True, True, 0)",
        "favorite": false
    },
    {
        "text": "    ",
        "favorite": false
    },
    {
        "text": "        favorite_button = Gtk.ToggleButton()\n        favorite_button.set_label(\"☆\" if not item.get(\"favorite\", False) else \"★\")\n        favorite_button.set_active(item.get(\"favorite\", False))\n        favorite_button.connect(\"toggled\", self.toggle_favorite, item[\"text\"])\n        hbox.pack_start(favorite_button, False, False, 0)",
        "favorite": false
    },
    {
        "text": "\n        favorite_button = Gtk.ToggleButton()\n        favorite_button.set_label(\"☆\" if not item.get(\"favorite\", False) else \"★\")\n        favorite_button.set_active(item.get(\"favorite\", False))\n        favorite_button.connect(\"toggled\", self.toggle_favorite, item[\"text\"])\n        hbox.pack_start(favorite_button, False, False, 0)",
        "favorite": true
    },
    {
        "text": "а почему кнопка одна когда должен быть список",
        "favorite": false
    }
]